\documentclass[12pt]{report}

\usepackage{amsmath,amssymb,amsfonts} %In case we need math stuff
\usepackage{graphicx} %For inserting images and stuff
\usepackage{listings} %For inserting code snippets
\usepackage{enumerate} %For fancy enumeration
\usepackage{hyperref}
\usepackage{pdfpages}
\usepackage{float}
\usepackage[margin=2cm]{geometry} %Nice margin setting

\renewcommand*\thesection{\arabic{section}}

\title{ECSE 321 - Intro to Software Engineering\\Release Pipeline Plan - Deliverable 4}
\author{Harley Wiltzer\\Camilo Garcia La Rotta\\Jake Shnaidman\\Robert Attard\\Matthew Lesko}
\date{April 2, 2017}

\begin{document}
\pagenumbering{gobble} %No page number on title page
\maketitle
\newpage
\pagenumbering{arabic} %Arabic numeral page numbers on regular pages
\tableofcontents
\part{Integration}
\section{Description}
\section{Tools}
\section{Design}
\section{Rationale}
\part{Build}
\section{Description}
The build pipeline is responsible for the successful and efficient building of the source code and
automated testing. As the system evolves, the processes required to carry out certain tasks like
compiling the code, creating executables, and running tests will evolve as well, and will ultimately
become more complex as time fades away. For this reason, it is important to design a robust automated
build system that provides the developers with the power to do any of the aforementioned tasks by
running simple build commands.\\\\
Of course, such power does not come from nothing; in fact, the developers must actively maintain
this build system such that it is always kept up to date with the rest of the system. Fortunately,
certain tools exist for creating such build systems that will significantly aid in the process.
These tools will be discussed in the \hyperref[s:build-tools]{Tools} section.
\section{Tools}
\label{s:build-tools}
Although designing a Monad in Haskell for automating build procedures sounds very interesting, such
a task would be a rather horrendous decision. Given the plethora of tools available that can already
be used to aid in the development of build systems, it is much preferred to use tools that have
already been tested and have already been shown to be efficient rather than developing one anew.\\\\
Firstly, designing and implementing build scripts, the Apache Ant tool will be used. A major
convenience of this tool is that it has support for both Java and PHP languages, which cover 100\%
of the languages used to implement the TAMAS system. Ant provides the ability to design multiple
\textit{build targets}, which are basically sets of building instructions that can be chosen and
sequenced when the build is invoked. If implemented properly, this would allow the code from
multiple platforms to be compiled individually or all at once, it would allow tests to be run
automatically (and perhaps different sets of tests depending on the user's choice), and would allow
executable files to be generated at will. Ultimately, Ant would provide the ability to create a
unified build suite for compilation, testing, packaging and friends, maximizing the convenience and
effectiveness of the developers in the build phase.\\\\
Furthermore, the Travis CI tool will be used for automated testing with Git integration. When synced
with Github, Travis CI can automatically run tests and communicate test results automatically
whenever a new commit is pushed. The Travis functionality is itself governed by a build file, which
will take advantage of the Ant build file that will be in the Git repository. Travis CI will be
incredible for ensuring that the entire development team is always up to date and informed
concerning the latest effectiveness of the code.
\section{Design}
This section will discuss the various design decisions made concerning the design of the build
system, and will provide a high level view of the build system implementation.
\subsection{Concerning the unification of the application platforms}
The first design decision made after deciding to use Apache Ant was to make one master build system
for all platforms of the application. Although all three application platforms serve different
purposes, and to the end user all platforms are literally separate, it would behoove the development
team to be able to manage the build procedures for all three with the same build script. This way,
should they find it appropriate, the developers may test code for more than one platform at once,
for example. It is projected that this will make the build process much more efficient. Of course,
the build system will be robust enough to give the user control over which platforms to target when
the build is invoked. Of course, this design choice was made possible thanks to only the magic
offered by Apache's Ant tool, which supports the testing protocols and compilers used for all
platforms in this system.
\section{Rationale}
\part{Deployment}
\section{Description}
Software deployment concerns all the tasks that cover the process of making a system available for public use.
This phase will be be activated once the integrated code has tested and approved by the preceding phase. At this moment the code is ready to be released to the public, In the case of the Desktop application through a web market or physical mean,for the Mobile application through the Android marketplace or an APK sharing forum and for the web application through a a production server, such as a hosting web server to ensure its availability on the web. In this section we will go through the tools, design choices and specificities of each platform's deployment phase.

\section{Tools}
Within the paradigm of automatizing and avoiding manual repetitive tasks that is applied throughout the release pipeline, we look now at tools which can help with the process of deployment. These tools must be able to transfer the binaries, libraries and all other required file for the proper function of the product to each platform in a seamless, error-less automated way. All while monitoring the process, gathering metrics which can help troubleshoot any errors or improve future deployments.

TODO ADD TOOLS FOR EACH PLATAFORM HERE WITH EXPLANATION (for web check out IIS web deploy as an example)

\section{Design}
The Deployment phase can be split into a set of well delimited activities which cover the entirety of the process. In this section we will describe them with relation to each available platform of the product.

\begin{itemize}
    \item \textbf{Release:}
    Once the approved code is received from the Build Phase, the global repository containing the three platform specific applications will be tagged with an incremental numerical ID which helps mark the end of the addition of a concrete sequence of fixes and upgrades to the existent applications. 
    
    The sub-repositories containing only each target platform application will then be delegated to its specific tool (addressed in the \textbf{Tools} section) for it to be deployed to the client. We will discuss this process for each platform:
    \begin{itemize}
        \item \textbf{Desktop:} LESKO
        \item \textbf{Mobile:} LESKO
        \item \textbf{Web:} Because of the small size of our product, all the required libraries and executable can be found under the sub-repository containing the web application. It suffices to transfer this folder to the web server's repository. It can be achieved through the web deployment tools explained in the previous section LESKOOOO
    \end{itemize}
    \item \textbf{Install/Activate:}
    This activity is related only to \textbf{Desktop} and \textbf{Mobile} targets, as the \textbf{Web} application is accessed through the web and doesn't host any permanent or temporary files client-side.
    
    \begin{itemize}
        \item \textbf{Desktop:} The \texttt{.jar} file can be placed anywhere the client wants. To avoid the need to handle OS specific file system architectures and scripting languages, once the executable is downloaded by the client the .jar will reside in the default download folder. From this point, it suffices for the client to run the executable through the method of his choice (Command Line of GUI) to access the application.
        \item \textbf{Mobile:} Once the client downloads the APK the Android application handler will automatically decompress it and install it. The client requires no further action in order to access the now installed application.
    \end{itemize}
    \item \textbf{Uninstall/Deactivate:} In the given case that one of our platforms stops being supported by the development team, a deactivation process starts. This process involves notifying the client of the end of support followed by the deactivation/uninstall of the application module.
        \begin{itemize}
        \item \textbf{Desktop:} LESKO
        \item \textbf{Mobile:} LESKO
        \item \textbf{Web:} The simplest target to deactivate, we only require to stop the web server daemon or the physical server itself.
    \end{itemize}
    \item \textbf{Update:} Following the same logic of a full release, a subtag (i.e. x.1) would be given to the global repository containing the updates applications. 
    \begin{itemize}
        \item \textbf{Desktop:} The old \texttt{.jar} must be overwritten with the new compiled executable. If the user desires to keep an older version of the application, he simply needs to store the file under different name. Multiple versions can work concurrently.
        \item \textbf{Mobile:} The android APK handler will receive the new APK and release a notification to all users who have the older version installed.
        \item \textbf{Web:} Through a blue-green deployment procedure, one of the servers web daemon will he halted, the necessary configuration or script files updated and the service restarted. Once the application is up online again without problem the green server will be taken down to pass through the same procedure. Hence no downtime will be perceivable client-side
    \end{itemize}
    \item \textbf{Version Tracking:} In order to provide a broader coverage of our application for the customers, an archive website will be kept from where all past versions of the application can be stored and retrieved from. This log of past versions will be linked to the GitHub repository containing the open-source code of the application. In addition to this link, GitHub provides the functionality of publishing a compressed archive version of the current code. This useful feauture will be used to maintain an accessible, visible release of the latest and past versions of the application in all its target states.
    \item \textbf{Monitoring:} Based on the aforementioned monitoring tools, we would keep an extensive log of the current amount of installed applications on all platforms, including their up-time, their error-logs and their amount of transactions. This would help identify and prioritize the requirements for the next iteration of development. In this section of the deployment phase we enter a more continuous analysis of the production application's state. Log analysis tools such as loggly, Splunk, logstash among others would help retrieve useful, tangible metrics on the deployed applications.
\end{itemize}
\section{Rationale}
\textbf{Why all this process:} As with any phase of the Release pipeline, the design choices for the Deployment are based on the goal of achieving an automated release where the versioning, archiving and delivery of the application produces minimal errors, if not none.\\\\
\textbf{Desktop Deployment:} LESKO\\\\
\textbf{Mobile Deployment:} LESKO\\\\
\textbf{Web Deployment:} Choosing approaches such as the blue-green technique for the web application can be backed by security reasons: 
\begin{itemize}
    \item Disaster Recovery in case a major bug went undetected through the Integration and Build Phases.
    \item Reducing, or even nullifying the downtime of a web service to the clients
    \item Being able to mantain multiple versions of an application on separate web-servers to ensure a broader support of client-side configurations
\end{itemize}\\\\
\textbf{Monitoring:} The main difference with the other two phases comes from the support tasks related with the monitoring of the delivered applications. It is a continuous process that's doesn't stop since the first public release of the application is made. This part of the Deployment is intrinsic to discover faults or new requirements that appears with the continuous use of the application. As such, the usage analysis tools for big log files comes as a natural automatisation step. The metrics gathered by these applications, as well as by the Android marketplace and GitHub itself ensure a better understanding of the usage, improvements and fall-pits of the product as sa whole.


\end{document}
