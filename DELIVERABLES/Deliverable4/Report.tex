\documentclass[12pt]{report}

\usepackage{amsmath,amssymb,amsfonts} %In case we need math stuff
\usepackage{graphicx} %For inserting images and stuff
\usepackage{listings} %For inserting code snippets
\usepackage{enumerate} %For fancy enumeration
\usepackage{hyperref}
\usepackage{pdfpages}
\usepackage{float}
\usepackage{dirtree}
\usepackage[margin=2cm]{geometry} %Nice margin setting

\renewcommand*\thesection{\arabic{section}}

\title{ECSE 321 - Intro to Software Engineering\\Release Pipeline Plan - Deliverable 4}
\author{Harley Wiltzer\\Camilo Garcia La Rotta\\Jake Shnaidman\\Robert Attard\\Matthew Lesko}
\date{April 2, 2017}

\begin{document}
\pagenumbering{gobble} %No page number on title page
\maketitle
\newpage
\pagenumbering{arabic} %Arabic numeral page numbers on regular pages
\tableofcontents
\part{Integration}
\section{Description}
The integration pipeline is responsible for maintaining the integrity of the source code throughout the development phase. Without proper integration, mistakes from one software developer can propagate into other people's work. Like an infectious disease, bugs can propagate. Infected code (Code that has bugs) that is shared can easily go unnoticed and affect larger systems where it can become even harder to notice. The goal of the integration pipeline is to reduce the amount of mistakes that will be integrated into the project and to keep track of all changes. The tools used for this purpose is discussed in the \hyperref[s:integration-tools]{Tools} section.
\section{Tools}
\label{s:integration-tools}
This section describes the tools that were used in the integration pipeline. The tools used for the integration pipeline include but are not limited to: Git, Github, TravisCI, JUnit, PHPUnit, and Slack.

\subsection{Git/Github}
Git is the name of the version control system that is used to track the changes of our source code. Github is the website that is used to host the source code. \\\\
The Git tool allows us to see how changes are made to the source code by our team members. Very importantly, it keeps our software developers accountable for the code that they write by keeping history of their contributions. Indeed, you can pinpoint the exact moment where software developers have made terrible mistakes. In these cases where the code has been rendered properly damaged, git allows you to revert to earlier stages in development before the mistake was made. Git also allows our members to work on code simultaneously which improves our productivity!\\\\
Github allows our team to not only seamlessly share our code, but provides shelter for our code. Github is reliable website to host our repositories and keep it safe from accidental deletion or accident.

\subsection{TravisCI}

\subsection{JUnit/PHPUnit}
JUnit and PHPUnit were used to throughly test our code. By ensuring that code is tested properly before being shared, it mitigated the amount of mistakes that were committed to our group's source code.\\\\
As one does in test-driven development, tests were written before the code was implemented. This kept our code on Github dependable.

\subsection{Slack}
Slack was not only used to aid communication across our team, but was integrated with Github to notify all of our team members of commits made. This made it easy to keep track of progress which was made which was important when pipelines had dependencies.
\section{Design}
This section specifies our team's design choices.

\subsection{Naming Conventions}
Our team came to decisions on certain naming conventions to keep our code consistent across platforms. This choice also makes it easier to read code written by other team members since the style remained consistent. This also made the code easier to interpret because it formalized the expectations of methods and variables. \\

\textbf{ \hyperref[s:integration-rationale]{The following lists are enumerated to link to the respective subsections to the Rationale section of the document}}

\begin{enumerate}
    \item By convention, all variables are listed at the top of a class if it is used throughout the class
    \item It was decided to keep method names as short as possible
    \item It was decided to keep the code split into three modules: Model, Persistence and Controller in all platforms
    \item It was decided to have method signatures followed by an open bracket on the same line
\end{enumerate}





\subsection{Tools}
\begin{enumerate}
    
\end{enumerate}

\section{Rationale}
\label{s:integration-rationale}
This section specifies the rationale for our team's design choices.

\subsection{Naming Conventions}
\begin{enumerate}
    \item We decided to list all the variables at the top of classes and not create a separate class for variables because we don't have many variables that are used across classes.
    \item Keeping method names as short as possible allowed for code to remain concise where possible
    \item Splitting code into three modules made it easier to know where to find classes within the projects
    \item Having method signatures followed by a bracket rather than have the opening bracket on the following line kept the code consistent which made it easier to track whether or not code has syntax errors
\end{enumerate}

\subsection{Tools}
\begin{enumerate}
    
\end{enumerate}



\part{Build}
\section{Description}
The build pipeline is responsible for the successful and efficient building of the source code and
automated testing. As the system evolves, the processes required to carry out certain tasks like
compiling the code, creating executables, and running tests will evolve as well, and will ultimately
become more complex as time fades away. For this reason, it is important to design a robust automated
build system that provides the developers with the power to do any of the aforementioned tasks by
running simple build commands.\\\\
Of course, such power does not come from nothing; in fact, the developers must actively maintain
this build system such that it is always kept up to date with the rest of the system. Fortunately,
certain tools exist for creating such build systems that will significantly aid in the process.
These tools will be discussed in the \hyperref[s:build-tools]{Tools} section.
\section{Tools}
\label{s:build-tools}
Although designing a Monad in Haskell for automating build procedures sounds very interesting, such
a task would be a rather horrendous decision. Given the plethora of tools available that can already
be used to aid in the development of build systems, it is much preferred to use tools that have
already been tested and have already been shown to be efficient rather than developing one anew.\\\\
Firstly, designing and implementing build scripts, the Apache Ant tool will be used. A major
convenience of this tool is that it has support for both Java and PHP languages, which cover 100\%
of the languages used to implement the TAMAS system. Ant provides the ability to design multiple
\textit{build targets}, which are basically sets of building instructions that can be chosen and
sequenced when the build is invoked. If implemented properly, this would allow the code from
multiple platforms to be compiled individually or all at once, it would allow tests to be run
automatically (and perhaps different sets of tests depending on the user's choice), and would allow
executable files to be generated at will. Ultimately, Ant would provide the ability to create a
unified build suite for compilation, testing, packaging and friends, maximizing the convenience and
effectiveness of the developers in the build phase.\\\\
Furthermore, the Travis CI tool will be used for automated testing with Git integration. When synced
with Github, Travis CI can automatically run tests and communicate test results automatically
whenever a new commit is pushed. The Travis functionality is itself governed by a build file, which
will take advantage of the Ant build file that will be in the Git repository. Travis CI will be
incredible for ensuring that the entire development team is always up to date and informed
concerning the latest effectiveness of the code.
\section{Design}
This section will discuss the various design decisions made concerning the design of the build
system, and will provide a high level view of the build system implementation.
\subsection{Concerning the unification of the application platforms}
The first design decision made after deciding to use Apache Ant was to make one master build system
for all platforms of the application. Although all three application platforms serve different
purposes, and to the end user all platforms are literally separate, it would behoove the development
team to be able to manage the build procedures for all three with the same build script. This way,
should they find it appropriate, the developers may test code for more than one platform at once,
for example. It is projected that this will make the build process much more efficient. Of course,
the build system will be robust enough to give the user control over which platforms to target when
the build is invoked. Of course, this design choice was made possible thanks to only the magic
offered by Apache's Ant tool, which supports the testing protocols and compilers used for all
platforms in this system.\\\\
The \hyperref[s:build-targets]{Build Targets section} will be split up by platform and will describe
the build targets for each.
Note that although platform discrimination is implicit in this structure, all targets will be
included in the same build file.

\subsection{The calm before the storm: an overview of the intended file structure}
\label{s:build-dirtree}
This section will give an overview of the file structure that is inherent to the build system's
design. Note that the directories and files suffixed with an asterisk denote directories and files
that are generated by the build system.\\\\\
\dirtree{%
	.1 APP/.
	.2 build*/.
	.3 jar*/.
	.4 <Executable Desktop JAR archive>*.
	.3 apk*/.
	.4 <Android APK>*.
	.3 web*/.
	.4 <Web Application zip archive>*.
	.3 desktop-classes*/.
	.4 <Desktop Class Files>*.
	.3 mobile-classes*/.
	.4 <Mobile Class Files>*.
	.2 Desktop/.
	.3 TAMAS/.
	.4 src/.
	.4 test/.
	.5 reports*/.
	.2 Web/.
	.3 ca.mcgill.ecse321.group10.TAMAS/.
	.4 index.php.
	.4 Model/.
	.4 View/.
	.4 Controller/.
	.4 Test/.
	.5 reports*/.
	.2 Mobile/.
	.3 MOBILE/.
	.4 app/.
	.5 src/.
}

\subsection{Build targets by platform}
\label{s:build-targets}
The following section will provide a catalog of build targets structured by the target platform.
Feel free to refer to \hyperref[s:build-dirtree]{directory map} above when reading the paths
mentioned below.
\subsubsection{Desktop}
The build targets intended for the desktop system will be enumerated below. 
\begin{enumerate}
	\item \texttt{init-desktop}\\
		Creates the requisite directories that will be needed for the remainder of the Desktop build
		targets
	\item \texttt{build-desktop}\\
		Sources the source files from the \texttt{APP/Desktop/TAMAS/src} directory and compiles
		them. Puts the compiled class files in \texttt{APP/build/desktop-classes}.\\
		Depends on \texttt{init-desktop}.
	\item \texttt{test-desktop}\\
		Runs all JUnit tests from the \texttt{APP/Desktop/TAMAS/test} directory and generates test
		reports to go to \texttt{APP/Desktop/TAMAS/test/reports}.\\
		Depends on \texttt{init-desktop}.
	\item \texttt{export-desktop}\\
		Makes executable JAR archive with the class files in \texttt{APP/build/desktop-classes}
		directory, and places JAR in \texttt{APP/build/jar}.\\
		Depends on \texttt{build-desktop}.
	\item \texttt{clean-desktop}\\
		Recursively removes all directories and files suffixed with an asterisk under the
		\texttt{APP/DESKTOP} directory and \texttt{build/desktop-classes} directory.
	\item \texttt{run-desktop}\\
		Launches the desktop application, executing the executable JAR file in
		\texttt{APP/build/jar}.
		Depends on \texttt{export-desktop}.
\end{enumerate}
\subsubsection{Web}
The following section will outline the build targets for the web application. Note that as PHP is an
\textit{interpreted} language, the code is not compiled, thus no compilation steps are included.
\begin{enumerate}
	\item \texttt{init-web}\\
		Creates the \texttt{APP/build/web} and
		\texttt{APP/Web/ca.mcgill.ecse321.grouip10.TAMAS/Test/reports} directories.
	\item \texttt{test-web}\\
		Runs the PHPUnit tests found in
		the \texttt{APP/Web/ca.mcgill.ecse321.grouip10.TAMAS/Test} directory, sends test reports to
		the \texttt{APP/Web/ca.mcgill.ecse321.grouip10.TAMAS/Test/reports} directory.\\
		Depends on \texttt{init-web}.
	\item \texttt{export-web}\\
		Makes a zip archive of the PHP files and stores it in \texttt{APP/build/web}.
	\item \texttt{run-web}\\
		This target will be included if it is found to be convenient. It will call a script that
		starts the XAMPP server and opens the \texttt{index.php} file in a browser.
\end{enumerate}
\subsubsection{Mobile}
Finally, the build system design targets related to the mobile platform will be shown. Note that
some of these targets depend on Desktop targets: this is because the Mobile application is heavily
dependent on the logic and model of the Desktop application.
\begin{enumerate}
	\item \texttt{init-mobile}\\
		Creates the directories requisite for the remainder of the mobile build targets.
	\item \texttt{build-mobile}\\
		Compiles the source code from the \texttt{APP/Mobile/MOBILE/app/src} directory, places
		compiled class files in \texttt{APP/build/mobile-classes}.\\
		Depends on \texttt{init-mobile,export-desktop}.
	\item \texttt{export-mobile}\\
		Builds the APK file and places it in \texttt{APP/build/apk}.\\
		Depends on \texttt{build-mobile}.
	\item \texttt{clean-mobile}\\
		Removes all created directories and files (directories and files suffixed by an asterisk in
		the \hyperref[s:build-dirtree]{directory map}) from within the \texttt{APP/mobile-classes}
		directory.
	\item \texttt{install-mobile}\\
		Calls a script to install the apk file onto the connected mobile device, or to run the apk
		on a virtual device if no physical device is connected.\\
		Depends on \texttt{export-mobile}.
\end{enumerate}
\subsubsection{Convenience Targets}
\label{s:build-convenience}
The following targets were designed merely for the convenience of the developers. 
\begin{enumerate}
	\item \texttt{clean-all}\\
		Calls \texttt{clean-desktop,clean-mobile}.
	\item \texttt{build-all}\\
		Calls \texttt{build-desktop,build-mobile}.
	\item \texttt{export-all}\\
		Calls \texttt{export-desktop, export-web, export-mobile}.
	\item \texttt{test-all}\\
		Calls \texttt{build-all, test-desktop, test-web}.
	\item \texttt{start-fresh}\\
		Removes all XML persistence files and calls \texttt{clean-all, build-all, test-all, export-all}.
	\item \texttt{pandemonium}\\
		Calls \texttt{clean-all, run-desktop, run-web, install-mobile}.
\end{enumerate}
\section{Rationale}
This section will attempt to explain the design choices that have been made. Though this be madness,
yet there is method in't.\\\\
The build system was designed to encapsulate each of the repetitive processes that may be automated
to save the developers trouble and keep the build process organized. As described above, build
targets for all three platforms are included in the same build script, so as to simplify the
automated build process for the developer.\\\\
The most intense platform to build is Desktop, and that comes as no surprise - the Desktop
application is used as a library for the Mobile application, and it also must be compiled unlike the
PHP application. Included in the Desktop build suite are an initialization routine, a compilation
routine, a testing routine, an exporting routine, a clean-up routine, and of course an execution
routine. This dismembers the build process into many parts, making the exact build procedure very
flexible. For example, the developer may compile code with \texttt{ant build-desktop}, or make a
\textit{clean build} by running \texttt{ant clean-desktop build-desktop}. A nice build process with
automated testing may be achieved with \texttt{ant build-desktop test-desktop}.\\\\
The build systems behave very similarly for the other platforms. As described previously, the Web
build system does not require a ``build'' target because the code does not get compiled.
Furthermore, the Web build system does not create an executable file in its ``export'' target, but
rather a zip file for packaging purposes (also, a website is not executed like an application).\\
On the other hand, the Mobile build system does not include any testing targets, because its logic
will all be tested within the Desktop system. Furthermore, instead of \textit{running} the
application, like in the Desktop's and Web's \texttt{run} targets, the Mobile system simply installs
the application on a device.\\\\
Finally, it is likely that the developers may need to build all systems at once. For this reason,
the \hyperref[s:build-convenience]{Convenience Targets} were conceived. Should the developer wish to
do a clean build and test everything, for example, this can be done with \texttt{ant start-fresh}.
If the developer wishes to compile everything, that may be done with \texttt{ant build-all}. All
targets listed in the Convenience Targets section were designed \textit{only} for convenience and
are not crucial to the build system.
\part{Deployment}
\section{Description}
Software deployment concerns all the tasks that cover the process of making a system available for public use.
This phase will be be activated once the integrated code has tested and approved by the preceding
phase. At this moment the code is ready to be released to the public, In the case of the Desktop
application through a web market or physical mean,for the Mobile application through the Android
marketplace or an APK sharing forum and for the web application through a a production server, such
as a hosting web server to ensure its availability on the web. In this section we will go through
the tools, design choices and specificities of each platform's deployment phase.

\section{Tools}
Within the paradigm of automatizing and avoiding manual repetitive tasks that is applied throughout the release pipeline, we look now at tools which can help with the process of deployment. These tools must be able to transfer the binaries, libraries and all other required file for the proper function of the product to each platform in a seamless, error-less automated way. All while monitoring the process, gathering metrics which can help troubleshoot any errors or improve future deployments.

The project will use Travis CI as the deployment tool for all platforms. The project's hosting provider shall be GitHub Releases. Travis CI can automatically upload assets from the Travis build directory to the team's git tags on the team's GitHub repository. \\
The main repository will contain a .travis.yml build file which will be used by Travis CI in order to build, automatically test and deploy the software system. The configuration for GitHub releases will be directly written in the .travis.yml file: \\
\begin{lstlisting}
deploy:
provider: releases
api_key: "GITHUB OAUTH TOKEN"
file: "FILE TO UPLOAD"
skip_cleanup: true
on:
tags: true
\end{lstlisting}

It is highly recommended to use "travis setup releases" which will automatically create a GitHub oauth token with the correct scopes and encrypts it for deployment.

\section{Design}
The Deployment phase can be split into a set of well delimited activities which cover the entirety of the process. In this section we will describe them with relation to each available platform of the product.

\begin{itemize}
   \item \textbf{Release:}
   Deploying GitHub Releases works only for tags, not for branches; hence the team will tag the current version of the software system if it is meant for deployment. The team will name tags that fit with semantic versioning: MAJOR.MINOR.PATCH. Every release will have a title and description. If the release is unstable, the team shall select GitHub's "This is a pre-release" option to notify users that it's not ready for production.\\
   
   Once the approved code is received from the Build Phase, the global repository containing the three platform specific applications will be tagged with an incremental numerical ID which fits with semantic versioning; this helps mark the end of the addition of a concrete sequence of fixes and upgrades to the existent applications. 
   
   The sub-repositories containing only each target platform application will then be delegated to the specific tool (addressed in the \textbf{Tools} section) for it to be deployed to the client. We will discuss this process for each platform:
   \begin{itemize}
   	\item \textbf{Desktop:} The desktop application and its repository shall be released on GitHub Releases as an Open Source Software project; allowing users to fork the repository and make their own changes. The desktop program shall be released as a .jar file with the repository; so that users may access and open the program directly through their explorer. The release process will release a certain branch that contains the project the team wishes to release.
   	\item \textbf{Mobile:} The mobile application and its repository shall be released on GitHub Releases as an Open Source Software project. The mobile application shall be packaged as an .apk (Android Application Package) file. Users will be able to fork the repository and make their own changes.
   	\item \textbf{Web:} Because of the small size of our product, all the required libraries and executable can be found under the sub-repository containing the web application. It suffices to transfer this folder to the web server's repository. It can be achieved through the web deployment tools explained in the previous section. The repository shall also be released on GitHub Releases as an OSS project and may be forked by other users.
   \end{itemize}
   Any and all applications may be downloaded and packaged in a zip folder from the GitHub repository.
   \item \textbf{Install/Activate:}
   This activity is related only to \textbf{Desktop} and \textbf{Mobile} targets, as the \textbf{Web} application is accessed through the web and doesn't host any permanent or temporary files client-side.
   
       \begin{itemize}
       	\item \textbf{Desktop:} The \texttt{.jar} file can be placed anywhere the client wants. To avoid the need to handle OS specific file system architectures and scripting languages, once the executable is downloaded by the client the .jar will reside in the default download folder. From this point, it suffices for the client to run the executable through the method of his choice (Command Line or GUI) to access the application.
       	\item \textbf{Mobile:} Once the client downloads the APK the Android application handler will automatically decompress it and install it. The client requires no further action in order to access the now installed application.
       \end{itemize}
    \item \textbf{Uninstall/Deactivate:} In the given case that one of our platforms stops being supported by the development team, a deactivation process starts. This process involves notifying the client of the end of support followed by the deactivation/uninstall of the application module.
    \begin{itemize}
    	\item \textbf{Desktop:} Uninstalling the desktop application involves deleting the .jar file of the main program and any output data that is stored in xml. If the user has cloned the repository on a local machine, then a full deactivation would require the deletion of the local repository and the user's forked repository on GitHub.
    	\item \textbf{Mobile:} Uninstalling the mobile application invloves uninstalling the application from the mobile phone and deletion of the .apk file by the use of a file manager for Android OS. If the user has cloned the repository on a local machine, then a full deactivation would require the deletion of the local repository and the user's forked repository on GitHub.
    	\item \textbf{Web:} The simplest target to deactivate, we only require to stop the web server daemon or the physical server itself.
    \end{itemize}
    \item \textbf{Update:} Following the same logic of a full release, a subtag (i.e. x.1) would be given to the global repository containing the updates applications. 
    \begin{itemize}
        \item \textbf{Desktop:} The old \texttt{.jar} must be overwritten with the new compiled executable. If the user desires to keep an older version of the application, he simply needs to store the file under different name. Multiple versions can work concurrently.
        \item \textbf{Mobile:} The android APK handler will receive the new APK and release a notification to all users who have the older version installed.
        \item \textbf{Web:} Through a blue-green deployment procedure, one of the servers web daemon will he halted, the necessary configuration or script files updated and the service restarted. Once the application is up online again without problem the green server will be taken down to pass through the same procedure. Hence no downtime will be perceivable client-side
    \end{itemize}
    \item \textbf{Version Tracking:} Versions of the release will be tracked by tags on GitHub.
    Since GitHub Releases requires the release to be tagged, each tag will contain all Patches, Minor, and/or Major updates specific to that software version. Each version and its changes can be viewed within the GitHub repository. Every release will be accompanied by release notes that specify the rationale and description of the release version. Along with the release notes are the commit number identifier, the time since the update has been released, the software version number, and download options (zip, and tar). In order to provide a broader coverage of our application for the customers, an archive website will be kept from where all past versions of the application can be stored and retrieved from. This log of past versions will be linked to the GitHub repository containing the open-source code of the application. In addition to this link, GitHub provides the functionality of publishing a compressed archive version of the current code. This useful feature will be used to maintain an accessible, visible release of the latest and past versions of the application in all its target states. 
    \item \textbf{Monitoring:} Based on the aforementioned monitoring tools, we would keep an extensive log of the current amount of installed applications on all platforms, including their up-time, their error-logs and their amount of transactions. This would help identify and prioritize the requirements for the next iteration of development. In this section of the deployment phase we enter a more continuous analysis of the production application's state. Log analysis tools such as loggly, Splunk, logstash among others would help retrieve useful, tangible metrics on the deployed applications.
\end{itemize}
\section{Rationale}
\textbf{Why all this process:} As with any phase of the Release pipeline, the design choices for the Deployment are based on the goal of achieving an automated release where the versioning, archiving and delivery of the application produces minimal errors, if not none.\\\\
\textbf{Desktop Deployment:} Using Travis CI as our deployment tool and GitHub Releases as our release host simplifies our deployment process. Travis CI has GitHub integration, it is quick to learn and easy to use; making it an optimal choice for the deployment tool. It has the capability of automatically releasing versions of our software tagged for release; which simplifies the release process. Using GitHub Releases as the release hosting solution helps reduce the time it takes to provide release notes (can be done as we tag the software version). Anyone who has a GitHub account can easily fork and download the release from GitHub releases; hence, our potential user base is over 20 million (20 million GitHub users).\\
\textbf{Mobile Deployment:} Similarly to the desktop application, deployment using Travis CI as the tool and GitHub Releases as the release hosting solution helps simplify the process to deploy the mobile application. The reason why we include the .apk file is because then anyone with an Android phone or emulator may install and use the mobile application quickly. The Android OS dominates roughly fifty percent of the smartphone OS market in the USA and Canada; hence, making our user base large.\\
\textbf{Web Deployment:} Choosing approaches such as the blue-green technique for the web application can be backed by security reasons: 
\begin{itemize}
    \item Disaster Recovery in case a major bug went undetected through the Integration and Build Phases.
    \item Reducing, or even nullifying the downtime of a web service to the clients
    \item Being able to maintain multiple versions of an application on separate web-servers to ensure a broader support of client-side configurations
\end{itemize}
\textbf{Monitoring:} The main difference with the other two phases comes from the support tasks
related with the monitoring of the delivered applications. It is a continuous process that's doesn't
stop since the first public release of the application is made. This part of the Deployment is
intrinsic to discover faults or new requirements that appears with the continuous use of the
application. As such, the usage analysis tools for big log files comes as a natural automatisation
step. The metrics gathered by these applications, as well as by the Android marketplace and GitHub
itself ensure a better understanding of the usage, improvements and fall-pits of the product as sa
whole.


\end{document}
